# 22 How to use RS-AC1



## 22.1 Introduction

This document illustrates how to connect the RS-AC1 to obtain point clouds, images, and IMU data.

For more info, please refer to the demo app `rs_driver/demo/demo_usb.cpp`. This example connects a single RS-AC1. 

Here the definitions of point and point cloud, is from the project file.

`rs_driver/src/rs_driver/msg/point_cloud_msg.hpp`, 
`rs_driver/src/rs_driver/msg/pcl_point_cloud_msg.hpp`, 
```rs_driver/src/rs_driver/msg/image_data_msg.hpp```,
```rs_driver/src/rs_driver/msg/imu_data_msg.hpp```



## 22.2 Steps

### 22.2.1 Define Point

Point is the base unit of Point Cloud. `rs_driver` supports these member variables.
- x -- The x coordinate of point. float type.
- y -- The y coordinate of point. float type.
- z -- The z coordinate of point. float type.
- intensity -- The intensity of point. uint8_t type. 
- timestamp -- The timestamp of point. double type.  It may be generated by the LiDAR or `rs_driver` on the host machine.
- ring -- The ring ID of the point, which represents the row/channel number. Take RS80 as an example, the range of ring ID is `0`~`79` (from bottom to top).

Below are some examples: 

- The point type contains **x, y, z, intensity**

  ```c++
  struct PointXYZI
  {
    float x;
    float y;
    float z;
    uint8_t intensity;
  };
  ```
  
- If using PCL, a simple way is to use **pcl::PointXYZI**.

- The point type contains **x, y, z, intensity, timestamp, ring**

  ```c++
  struct PointXYZIRT
  {
    float x;
    float y;
    float z;
    uint8_t intensity;
    double timestamp;
    uint16_t ring;
  };
  ```

Here user may add new member variables, remove member variables, or change the order of them, but should not change names or types of them.

### 22.2.2 Define Point Cloud

  Below is the definition of point cloud.

  ```c++
  template <typename T_Point>
  class PointCloudT
  {
  public:
    typedef T_Point PointT;
    typedef std::vector<PointT> VectorT;

    uint32_t height = 0;    ///< Height of point cloud
    uint32_t width = 0;     ///< Width of point cloud
    bool is_dense = false;  ///< If is_dense is true, the point cloud does not contain NAN points
    double timestamp = 0.0; ///< Timestamp of point cloud
    uint32_t seq = 0;       ///< Sequence number of message

    VectorT points;
  };
  ```

  Here user may add new members, and change the order of these members, but should not change or remove them.

  This definition is a template class. It needs a Point type as template parameter.

  ```
  typedef PointXYZI PointT;
  typedef PointCloudT<PointT> PointCloudMsg;
  ```


### 22.2.3 Define the driver object

Define a driver object.

```c++
int main()
{
  LidarDriver<PointCloudMsg> driver;          ///< Declare the driver object
  ...
}
```

### 22.2.4 Configure the driver parameter

Define a RSDriverParam variable and configure it.
+ `InputType::USB` means the device is connected via USB.
+ `LidarType::RS_AC1` means a RS-AC1.

```c++
int main()
{
  ...
  RSDriverParam param;                            ///< Create a parameter object
  param.input_type = InputType::USB;              ///< Get packet from online lidar
  param.lidar_type = LidarType::RS_AC1;           ///< Set the lidar type. Ensure the type is correct

  // param.input_param.device_uuid = "0x12345678";   ///< Set the device UUID
  param.decoder_param.ts_first_point = true;      ///< Use the timestamp of the first point
  param.input_param.enable_image = true;          ///< Enable image stream
  param.input_param.image_format = FRAME_FORMAT_NV12; ///< Set image format to NV12
  param.input_param.image_width = 1920;           ///< Set image width to 1920
  param.input_param.image_height = 1080;          ///< Set image height to 1080
  param.input_param.image_fps = 15;               ///< Set image FPS to 15
  ...
}
```

### 22.2.5 Define and register Point Cloud callbacks

+ User is supposed to provide free point cloud to `rs_driver`. Here is the first callback. 

```c++
SyncQueue<std::shared_ptr<PointCloudMsg>> free_cloud_queue;

std::shared_ptr<PointCloudMsg> driverGetPointCloudFromCallerCallback(void)
{
  std::shared_ptr<PointCloudMsg> msg = free_cloud_queue.pop();
  if (msg.get() != NULL)
  {
    return msg;
  }

  return std::make_shared<PointCloudMsg>();
}
```

+ `rs_driver` returns stuffed point cloud to user.  Here is the second callback.

```c++
SyncQueue<std::shared_ptr<PointCloudMsg>> stuffed_cloud_queue;

void driverReturnPointCloudToCallerCallback(std::shared_ptr<PointCloudMsg> msg)
{
  stuffed_cloud_queue.push(msg);

  RS_MSG << "msg: " << msg->seq << " point cloud size: " << msg->points.size() << RS_REND;
}
```

Note: The driver calls these two callback functions in the Points Packet handling thread, so **don't do any time-consuming task** in them. 

+ User creates a new thread to processes the point cloud.

```c++
void processCloud(void)
{
  while (1)
  {
    std::shared_ptr<PointCloudMsg> msg = stuffed_cloud_queue.popWait();
    if (msg.get() == NULL)
    {
      continue;
    }

    // Well, it is time to process the point cloud msg, even it is time-consuming.
    RS_MSG << "msg: " << msg->seq << " point cloud size: " << msg->points.size() << RS_REND;

    free_cloud_queue.push(msg);
  }
}

```

+ Register them to `rs_driver`.

```c++
int main()
{
  ...
  driver.regPointCloudCallback(driverReturnPointCloudToCallerCallback, 
                               driverReturnPointCloudToCallerCallback);
  ...
}
```

### 22.2.6 Define and register the IMU callback function


+ Similar to acquiring point clouds, the `rs_driver` requires the caller to provide an free IMU data instance through a callback function. Here, the first IMU callback function is defined.

```c++
SyncQueue<std::shared_ptr<ImuData>> free_imu_data_queue;

std::shared_ptr<ImuData> driverGetIMUDataFromCallerCallback(void)
{
  std::shared_ptr<ImuData> msg = free_imu_data_queue.pop();
  if (msg.get() != NULL)
  {
    return msg;
  }

  return std::make_shared<ImuData>();
}
```

+ `rs_driver` returns stuffed IMU data to user.  Here is the second callback.

```c++
SyncQueue<std::shared_ptr<ImuData>> stuffed_imu_data_queue;

void driverReturnImuDataToCallerCallback(const std::shared_ptr<ImuData>& msg)
{
  stuffed_imu_data_queue.push(msg);
}
```

Note: The driver calls these two callback functions in the IMU handling thread, so **don't do any time-consuming task** in them. 

+ User creates a new thread to processes the IMU data.

```c++
void processImuData(void)
{
  uint32_t imu_cnt = 0;
  while (!to_exit_process)
  {
    std::shared_ptr<ImuData> msg = stuffed_imu_data_queue.popWait();
    if (msg.get() == NULL)
    {
      continue;
    }

    // Well, it is time to process the IMU data msg, even it is time-consuming.
    RS_MSG << "msg: " << imu_cnt << " imu data ts: " <<std::dec<<std::to_string(msg->timestamp) << RS_REND;

    imu_cnt++;
#if 0
    RS_DEBUG  <<"imu data: " << " , linear_a_x" << msg->linear_acceleration_x 
      << " , linear_a_y " << msg->linear_acceleration_y << "  , linear_a_z" << msg->linear_acceleration_z   
      << " , angular_v_x " << msg->angular_velocity_x << " , angular_v_y" << msg->angular_velocity_y 
      << " , angular_v_z" <<msg->angular_velocity_z << RS_REND;
#endif

    free_imu_data_queue.push(msg);
  }
}

```

+ Register them to `rs_driver`.

```c++
int main()
{
  ...
#if ENABLE_IMU_PARSE
  driver.regImuDataCallback(driverGetIMUDataFromCallerCallback, driverReturnImuDataToCallerCallback);
#endif
  ...
}
```


### 22.2.7 Define and register the Image callback function

+ Similar to acquiring point clouds, the `rs_driver` requires the caller to provide an free Image data instance through a callback function. Here, the first Image callback function is defined.

```c++
SyncQueue<std::shared_ptr<ImageData>> free_image_data_queue;;

std::shared_ptr<ImageData> driverGetImageDataFromCallerCallback(void)
{
  std::shared_ptr<ImageData> msg = free_image_data_queue.pop();
  if (msg.get() != NULL)
  {
    return msg;
  }

  return std::make_shared<ImageData>();
}
```

+ `rs_driver` returns stuffed Image data to user.  Here is the second callback.

```c++
SyncQueue<std::shared_ptr<ImageData>> stuffed_image_data_queue;

void driverReturnImageDataToCallerCallback(const std::shared_ptr<ImageData>& msg)
{
  stuffed_image_data_queue.push(msg);
}
```

Note: The driver calls these two callback functions in the Image handling thread, so **don't do any time-consuming task** in them. 

+ User creates a new thread to processes the Image data.

```c++
void processImageData(void)
{
  uint32_t image_cnt = 0;
  while (!to_exit_process)
  {
    std::shared_ptr<ImageData> msg = stuffed_image_data_queue.popWait();
    if (msg.get() == NULL)
    {
      continue;
    }

    // Well, it is time to process the Image data msg, even it is time-consuming.

    image_cnt++;

#if 1
    RS_MSG << "msg: " << image_cnt << " image data ts: " <<std::dec<<std::to_string(msg->timestamp) << RS_REND;
    // RS_MSG << "msg: " << image_cnt << " image data format: " <<std::dec<<std::to_string(msg->frame_format) << RS_REND;
#endif

    free_image_data_queue.push(msg);
  }
}
```

+ Register them to `rs_driver`.

```c++
int main()
{
  ...
#if ENABLE_IMAGE_PARSE
  driver.regImageDataCallback(driverGetImageDataFromCallerCallback, driverReturnImageDataToCallerCallback);
#endif
  ...
}
```


### 22.2.8 Define and register exception callbacks

+ When an error happens, `rs_driver` informs user. Here is the exception callback.

```c++
void exceptionCallback(const Error &code)
{
  RS_WARNING << "Error code : " << code.toString() << RS_REND;
}
```

Once again, **don't do any time-consuming task** in it.

+ Register the callback.

```c++
int main()
{
  ...
  driver.regExceptionCallback(exceptionCallback);  ///<Register the exception callback function
  ...
}
```

### 22.2.9 Initialize the driver

Initialize `rs_driver` with the the RSDriverParam object.

```c++
int main()
{
  ...
  if (!driver.init(param))  ///< Call the init function with the parameter
  {
    RS_ERROR << "Driver Initialize Error..." << RS_REND;
    return -1;
  }
  ...
}
```

### 22.2.10 Start the driver

Start `rs_driver`.

```c++
int main()
{
  ...
  driver.start();  ///< Call the start function. The driver thread will start
  ...
}
```

### 22.2.11 Congratulation

Compile rs_driver and run it. It should print message as below.

```c++
RoboSense Lidar-Driver Linux usb demo start......
msg: 1 imu data ts: 1741941730.782551
msg: 2 imu data ts: 1741941730.787492
msg: 3 imu data ts: 1741941730.792433
msg: 4 imu data ts: 1741941730.797375
msg: 5 imu data ts: 1741941730.802317
msg: 6 imu data ts: 1741941730.807259
msg: 7 imu data ts: 1741941730.812200
msg: 8 imu data ts: 1741941730.817142
msg: 9 imu data ts: 1741941730.822084
msg: 10 imu data ts: 1741941730.827025
msg: 11 imu data ts: 1741941730.831972
msg: 12 imu data ts: 1741941730.836911
msg: 13 imu data ts: 1741941730.841850
msg: 1 image data ts: 8.599935
msg: 14 imu data ts: 1741941730.846792
msg: 15 imu data ts: 1741941730.851734
msg: 16 imu data ts: 1741941730.856688
msg: 1 point cloud size: 27648
msg: 17 imu data ts: 1741941730.861617
msg: 2 image data ts: 8.599935
msg: 18 imu data ts: 1741941730.866559
msg: 19 imu data ts: 1741941730.871505
msg: 20 imu data ts: 1741941730.876460
msg: 3 image data ts: 8.666600
msg: 21 imu data ts: 1741941730.881384
msg: 22 imu data ts: 1741941730.886326
msg: 23 imu data ts: 1741941730.891266
```
